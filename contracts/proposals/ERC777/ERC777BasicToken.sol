pragma solidity ^0.4.24;

import { ERC777Token } from "./ERC777Token.sol";
import { ERC777TokensRecipient } from "./ERC777TokensRecipient.sol";
import { ERC777TokensSender } from "./ERC777TokensSender.sol";
import { ERC820Implementer } from "../ERC820/ERC820Implementer.sol";
import { Ownable } from "../../ownership/Ownable.sol";
import { SafeMath } from "../../math/SafeMath.sol";


contract ERC777BasicToken is ERC777Token, ERC820Implementer, Ownable {
    using SafeMath for uint256;

    // Token name
    string internal name_;

    // Token symbol
    string internal symbol_;

    // Mapping from owner to number of owned tokens (owner's token balance)
    mapping(address => uint) internal tokenBalances;

    // Defines the smallest part of the token that's not divisible.
    uint256 internal granularity_;

    // Defines the total number of tokens
    uint256 internal totalSupply_;

    // Mapping from operator to a mapping from owner to a boolean indicating whether the operator is authorized for
    // the owner
    mapping(address => mapping(address => bool)) internal operators;

    address[] internal defaultOperators_;
    mapping(address => bool) internal isDefaultOperator;
    mapping(address => mapping(address => bool)) internal revokedDefaultOperator;


    constructor(string _name, string _symbol, uint256 _granularity, address[] _defaultOperators) public {
        require(_granularity >= 1);
        name_ = _name;
        symbol_ = _symbol;
        totalSupply_ = 0;
        granularity_ = _granularity;
        defaultOperators_ = _defaultOperators;
        for (uint i = 0; i < defaultOperators_.length; i++) {
            isDefaultOperator[defaultOperators_[i]] = true;
        }
        // register the interface to conform to ERC777 via ERC820
        setInterfaceImplementation("ERC777Token", this);
    }

    /*  ERC777 Interface Implementation */
    /// @return the name of the token
    function name() external view returns (string) {
        return name_;
    }

    /// @return the symbol of the token
    function symbol() external view returns (string) {
        return symbol_;
    }

    /// @return the granularity of the token
    function granularity() external view returns (uint256) {
        return granularity_;
    }

    /// @return the total supply of the token
    function totalSupply() external view returns (uint256) {
        return totalSupply_;
    }

    /// @dev Return the account balance of an address
    /// @param _owner Address whose balance is returned
    /// @return the balance of `_owner`
    function balanceOf(address _owner) public view returns (uint256) {
        return tokenBalances[_owner];
    }

    /// @dev Send `_amount` of tokens to address `_to` passing `_userData` to the recipient
    /// @param _to The address of the recipient
    /// @param _amount The number of tokens to be sent
    function send(address _to, uint256 _amount, bytes _userData) external {
        sendTokens(msg.sender, _to, _amount, _userData, msg.sender, "", true);
    }

    /// @dev Helper function which sends the tokens.
    /// @param _from The address of the owner of the tokens
    /// @param _to The address of the recipient
    /// @param _amount The number of tokens to be sent
    /// @param _userData Data generated by the user to be passed to the recipient
    /// @param _operatorData Data generated by the operator to be passed to the recipient
    /// @param _preventLocking `true` causes function to throw when tokens are sent to a contract address that does not
    ///  implement `erc777_tokenHolder`, preventing loss of funds due to locking
    ///  ERC777 native Send functions MUST set this parameter to `true`, and backwards compatible ERC20 transfer
    ///  functions should set this parameter to `false`.
    function sendTokens(
        address _from,
        address _to,
        uint256 _amount,
        bytes _userData,
        address _operator,
        bytes _operatorData,
        bool _preventLocking
    )
    internal
    {
        // require that the amount being transferred is a multiple of granularity
        requireMultiple(_amount);
        // forbid burning tokens by sending to 0x0
        require(_to != address(0x0));
        // ensure owner has enough in balance to send funds
        require(tokenBalances[_from] >= _amount);
        // call sending hook
        callSender(_operator, _from, _to, _amount, _userData, _operatorData);
        // update balances
        tokenBalances[_from] = tokenBalances[_from].sub(_amount);
        tokenBalances[_to] = tokenBalances[_to].add(_amount);
        // call receiving hook
        callRecipient(_operator, _from, _to, _amount, _userData, _operatorData, _preventLocking);
        // emit Sent event
        emit Sent(_operator, _from, _to, _amount, _userData, _operatorData);
    }

    /// @dev Helper function that checks for ERC777TokensRecipient on the recipient and calls it.
    ///  May throw if `_preventLocking` is true and interface is not registered
    /// @param _from The address holding the tokens being sent
    /// @param _to The address of the recipient
    /// @param _amount The number of tokens to be sent
    /// @param _userData Data generated by the user to be passed to the recipient
    /// @param _operatorData Data generated by the operator to be passed to the recipient
    /// @param _preventLocking `true` if you want this function to throw when tokens are sent to a contract not
    ///  implementing `ERC777TokensRecipient`.
    ///  ERC777 native Send functions MUST set this parameter to `true`, and backwards compatible ERC20 transfer
    ///  functions SHOULD set this parameter to `false`.
    function callRecipient(
        address _operator,
        address _from,
        address _to,
        uint256 _amount,
        bytes _userData,
        bytes _operatorData,
        bool _preventLocking
    )
    internal
    {
        address recipientImplementation = interfaceAddr(_to, "ERC777TokensRecipient");
        if (recipientImplementation != 0) {
            ERC777TokensRecipient(recipientImplementation).tokensReceived(
                _operator, _from, _to, _amount, _userData, _operatorData);
        } else if (_preventLocking) {
            require(isRegularAddress(_to));
        }
    }

    function defaultOperators() external view returns (address[]){
        return defaultOperators_;
    }

    /// @dev Helper function that checks for ERC777TokensSender on the sender and calls it.
    ///  May throw according to `_preventLocking`
    /// @param _from The address holding the tokens being sent
    /// @param _to The address of the recipient
    /// @param _amount The amount of tokens to be sent
    /// @param _userData Data generated by the user to be passed to the recipient
    /// @param _operatorData Data generated by the operator to be passed to the recipient
    ///  implementing `ERC777TokensSenderInterface`.
    ///  ERC777 native Send functions MUST set this parameter to `true`, and backwards compatible ERC20 transfer
    ///  functions SHOULD set this parameter to `false`.
    function callSender(
        address _operator,
        address _from,
        address _to,
        uint256 _amount,
        bytes _userData,
        bytes _operatorData
    )
    internal
    {
        address senderImplementation = interfaceAddr(_from, "ERC777TokensSender");
        if (senderImplementation != 0) {
            ERC777TokensSender(senderImplementation).tokensToSend(_operator, _from, _to, _amount, _userData, _operatorData);
        }
    }

    /// @dev Authorize a third party `_operator` to have the ability to send `msg.sender`'s tokens
    /// @param _operator The address to authorize as an operator
    function authorizeOperator(address _operator) external {
        require(_operator != msg.sender);
        if (isDefaultOperator[_operator]) {
            revokedDefaultOperator[_operator][msg.sender] = false;
        } else {
            operators[_operator][msg.sender] = true;
        }
        emit AuthorizedOperator(_operator, msg.sender);
    }

    /// @dev Revoke msg.sender's `_operator`'s ability to send `msg.sender`'s tokens
    /// @param _operator The address to revoke operator privilege from
    function revokeOperator(address _operator) external {
        require(_operator != msg.sender);
        if (isDefaultOperator[_operator]) {
            revokedDefaultOperator[_operator][msg.sender] = true;
        } else {
            operators[_operator][msg.sender] = false;
        }
        emit RevokedOperator(_operator, msg.sender);
    }

    /// @dev Check whether the `_operator` address is allowed to manage the tokens held by `_tokenHolder` address.
    /// @param _operator address to check if it has the right to manage the tokens
    /// @param _tokenHolder address which holds the tokens to be managed
    /// @return `true` if `_operator` is authorized for `_tokenHolder`
    function isOperatorFor(address _operator, address _tokenHolder) public view returns (bool) {
        return (_operator == _tokenHolder
        || operators[_operator][_tokenHolder]
        || (isDefaultOperator[_operator] && !revokedDefaultOperator[_operator][_tokenHolder]));
    }

    /// @dev Send `_amount` of tokens on behalf of the address `from` to the address `to`.
    /// @param _from The address holding the tokens being sent
    /// @param _to The address of the recipient
    /// @param _amount The number of tokens to be sent
    /// @param _userData Data generated by the user to be sent to the recipient
    /// @param _operatorData Data generated by the operator to be sent to the recipient
    function operatorSend(address _from, address _to, uint256 _amount, bytes _userData, bytes _operatorData) external {
        require(isOperatorFor(msg.sender, _from));
        sendTokens(_from, _to, _amount, _userData, msg.sender, _operatorData, true);
    }

    /* -- Mint And Burn Functions (not part of the ERC777 standard, only the Events/tokensReceived call are) -- */
    //
    /// @notice Generates `_amount` tokens to be assigned to `_tokenHolder`
    ///  Sample mint function to showcase the use of the `Minted` event and the logic to notify the recipient.
    /// @param _tokenHolder The address that will be assigned the new tokens
    /// @param _amount The quantity of tokens generated
    /// @param _operatorData Data that will be passed to the recipient as a first transfer
    function mint(address _tokenHolder, uint256 _amount, bytes _operatorData) public onlyOwner {
        require(_amount > 0);
        requireMultiple(_amount);
        totalSupply_ = totalSupply_.add(_amount);
        tokenBalances[_tokenHolder] = tokenBalances[_tokenHolder].add(_amount);

        callRecipient(msg.sender, 0x0, _tokenHolder, _amount, "", _operatorData, true);
        emit Minted(msg.sender, _tokenHolder, _amount, "", _operatorData);
    }

    /// @notice Burns `_amount` tokens from `_tokenHolder`
    ///  Sample burn function to showcase the use of the `Burned` event.
    /// @param _tokenHolder The address that will lose the tokens
    /// @param _amount The quantity of tokens to burn
    function burn(address _tokenHolder, uint256 _amount, bytes _userData, bytes _operatorData) external onlyOwner {
        requireMultiple(_amount);

        callSender(msg.sender, _tokenHolder, 0x0, _amount, _userData, _operatorData);

        require(balanceOf(_tokenHolder) >= _amount);

        tokenBalances[_tokenHolder] = tokenBalances[_tokenHolder].sub(_amount);
        totalSupply_ = totalSupply_.sub(_amount);

        emit Burned(msg.sender, _tokenHolder, _amount, _operatorData);
    }

    /* -- Helper Functions -- */
    //
    /// @dev Internal function that ensures `_amount` is multiple of the granularity
    /// @param _amount The quantity that want's to be checked
    function requireMultiple(uint256 _amount) internal view {
        require(_amount.div(granularity_).mul(granularity_) == _amount);
    }

    /// @dev Check whether an address is a regular address or not.
    /// @param _account Address of the contract that has to be checked
    /// @return `true` if `_account` is a regular address (not a contract)
    function isRegularAddress(address _account) internal constant returns(bool) {
        if (_account == 0) {
            return false;
        }
        uint size;
        assembly { size := extcodesize(_account) }
        return size == 0;
    }

}
